#include "mbed.h"
#include "QEI.h"
Ticker Systicker;
//leftmost(LM) receiver(R) PC_0
//leftmost(LM) emitter(E) PB_7
AnalogIn   LMR(PC_0);
DigitalOut LME(PB_7);
//upperleft(UL) receiver(R) PC_1
//upperleft(UL) emitter(E) PB_0
AnalogIn   ULR(PC_1);
DigitalOut ULE(PB_0);
//upperright(UR) receiver(R) PA_4
//upperright(UR) emitter(E) PC_11
AnalogIn   URR(PA_4);
DigitalOut URE(PC_11);
//rightmost(RM) receiver(R) PA_0
//rightmost(RM) emitter(E)  PC_10
AnalogIn   RMR(PA_0);
DigitalOut RME(PC_10);
PwmOut M1F(PC_7);
PwmOut M1B(PB_10);
PwmOut M2F(PB_6);
PwmOut M2B(PA_7);
QEI M1Encoder (PB_3, PA_15, NC, 12);
QEI M2Encoder (PA_1, PC_4, NC, 12);
int pulsePerInch = 140;
bool P_enable=true;
Serial pc(PA_11, PA_12);
float leftIR,rightIR;
float kp=0.0005;
void systick()
{
    if (!P_enable) return;
    //p
    if (rightIR>leftIR) M1F=M1F+kp*(rightIR-leftIR);
    else if (leftIR>rightIR) M2F=M2F+kp*(leftIR-rightIR);
    if (M1F>0.4 || M2F>0.4) {
        M1F=0.15;
        M2F=0.15;
    }
}
int main()
{
    M1F = 0.15;
    M1B = 0;
    M2F = 0.15;
    M2B = 0;
    M1Encoder.reset();
    M2Encoder.reset();
    LME = 1;
    ULE = 0;
    URE = 0;
    RME = 1;
    Systicker.attach_us(&systick, 1000);
    while(1) {
        rightIR=RMR.read();
        leftIR=LMR.read();
        // pc.printf("%f\n",rightIR-leftIR);
        //pc.printf ("\nLMR Sensor Values:%f\n", LMR.read());
        //code to turn left
        if(leftIR < 0.38) {
            P_enable=false;
            M1Encoder.reset();
            M2Encoder.reset();
            //going straight 6 inches until turn
            while (M1Encoder.getPulses() < pulsePerInch*6 && M2Encoder.getPulses() < pulsePerInch*6) {
                M1F = 0.15;
                M1B = 0;
                M2F = 0.15;
                M2B = 0;
            }
            M1Encoder.reset();
            M2Encoder.reset();
            //turning left
            while (M1Encoder.getPulses() < pulsePerInch*2.45 && M2Encoder.getPulses() < pulsePerInch*2.45) {
                M1F = 0.3;
                M1B = 0;
                M2F = 0;
                M2B = 0.3;
            }
            M1F = 0.15;
            M1B = 0;
            M2F = 0.15;
            M2B = 0;
            M1Encoder.reset();
            M2Encoder.reset();
            P_enable=true;
        }
        else if(rightIR < 0.38) {
            P_enable=false;
            M1Encoder.reset();
            M2Encoder.reset();
            //going straight 6 inches until turn
            while (M1Encoder.getPulses() < pulsePerInch*6 && M2Encoder.getPulses() < pulsePerInch*6) {
                M1F = 0.15;
                M1B = 0;
                M2F = 0.15;
                M2B = 0;
            }
            M1Encoder.reset();
            M2Encoder.reset();
            //turning right
            while (M1Encoder.getPulses() < pulsePerInch*2.45 && M2Encoder.getPulses() < pulsePerInch*2.45) {
                M1F = 0;
                M1B = 0.3;
                M2F = 0.3;
                M2B = 0;
            }
            M1F = 0.15;
            M1B = 0;
            M2F = 0.15;
            M2B = 0;
            M1Encoder.reset();
            M2Encoder.reset();
            P_enable=false;
        }
    }
}
